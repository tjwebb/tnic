#summary Describes how to design and write your own TNIC programs.

= Background =
TNIC allows the implementor to develop programs that can be automatically
distributed among different computing resources. A desirable side-effect of
tnic's design philosophy is that it allows rapid prototyping and fail-safe
modification of programs during runtime, and it encourages software re-use
through the development of loosely-coupled modules.

= Quick-Start =
We'll start with a simple example of a tnic program that finds all prime
numbers in the fibonacci sequence. This program is split into two modules
and a supervisor. Module `fib` computes the fibonacci sequence, module `prime`
detects a prime number, and `supervisor` begins the execution and analyzes
the result once the program is finished. The supervisor defines a series of
guards (see: [http://en.wikipedia.org/wiki/Guard_(computing)]) that define the 
flow of logic. The function names `supervisor`, `init`, and `join` are all
reserved function names in tnic, so no modules or functions can have these
names. The example below is in Javascript.

== Example Code ==

=== Supervisor ===
{{{
    /**
     * com.tnic.example.supervisor
     * Return all prime numbers in the fibonacci sequence
     */
    function init () {
        return {
            "com.tnic.example.fib" : {
                guard : [ "com.tnic.example.supervisor" ],
            },
            "com.tnic.example.prime" : {
                guard : [ "com.tnic.example.fib" ],
                cond  : function (z) { return (z < 10000); }
            }
            "space" : {
                prime_list : [ ],
                counter    : 0
            }
        };
    }
    function supervisor ($) {
        var n = 100;
        if ($.space.counter >= n) {
            return false;
        }
        else {
            if (true === $.prime.result) {
                $.space.prime_list.add(space.fib.result);
            }
            return $.space.counter++;
        }
    }
    function join (space) {
        print ("The fibonacci primes < "+ n +" are: "+ $.space.prime_list);
    }
}}}
=== Fibonacci Module ===
{{{
    /**
     * com.tnic.example.fib
     * Compute the next integer in the fibonacci sequence
     * @param the previous number in the sequence
     * @return {integer} the next number in the sequence
     */
    function fib (n)
        if (n == 0 || n == 1) return 1;
        return fib(n - 2) + fib(n - 1);
    }
}}}
=== Prime Number Validator Module ===
{{{
    /**
     * com.tnic.example.prime
     * Detects if an integer is prime
     * @param the integer to process
     * @return true if prime, false otherwise
     */
     function prime (num) {
        for (var i = 2; i <= sqrt(num); i++) {
            if (num % i == 0) return false;
        }
        return true;
     }
}}}

= Explanation =
To summarize again, this program finds all fibonacci primes up to 100. The
execution begins with the supervisor. Once the supervisor function is finished,
the module or modules with the supervisor as their guard will be invoked. In
this example, one module is guarding on the supervisor: the `fib` module. 
Likewise, once `fib` is done executing, all modules guarded on `fib` will
be invoked, i.e. `prime`.

Now, we'll go through each piece in detail so that you can begin writing your 
own TNIC programs.

== Guard Object ==
{{{
{
    "moduleA" : {
        guard : "moduleB"
        cond  : function (z) { return (z == 1); }
    }
    ...
}
}}}
The object is keyed by module, so here we are defining the guard template for
`moduleA`. In the case of `guard : `moduleB` we are instructing moduleA to wait
until moduleB is finished executing, and to only run if `(z == 1)`
evaluates to true. When defining a condition (`cond`), the argument z that is
passed into the condition function is the result from the previous module--in
this case, z is the result returned by moduleB. Generally, the supervisor will
impose conditions on the modules that it guards on in order to halt the
execution of the program at some point.
Also since distributed systems are not guaranteed to have the resources to
execute module logic at any particular point in time, a module will, by
default, wait until resources are available to execute. Even though the
distributed nature of the system is designed to avoid such situations, this
is necessary to ensure orderly execution of TNIC programs.

== How to Write A Supervisor ==
The supervisor is a special module that directs the execution of its
subordinate modules. The supervisor module consists of three functions: `init()`
and `supervisor()`, and `join()`.

=== `init()` function ===
The init function returns a hash-table object (aka JSON) that directs the flow
of the program, and the items allowed in the object space. The table is keyed
by module name. It is copied below for easy reference:
{{{
{
    "com.tnic.example.fib" : {
        guard : [ "com.tnic.example.supervisor" ],
    },
    "com.tnic.example.prime" : {
        guard : [ "com.tnic.example.fib" ],
        cond  : function (z) { return (z < 10000); }
    }
    "space" : {
        prime_list : [ ],
        counter    : 0
    }
}
}}}
==== _Guard Templates_ ====
Let's take the key `com.tnic.exmaple.prime` as an example. It contains two
properties: `guard` and `cond`. `guard` defines the modules upon which this
module depends, and `cond` defines a precondition that must be satisfied if
`prime` is to be invoked. If at any point in execution a condition defined by
`cond` evaluates to false, the supervisor is immediately invoked.
The English description of the guard template for `com.tnic.example.prime` is
as follows: The `prime` module depends on the result of `com.tnic.example.fib`,
so do not run until `fib` returns a result. As a precondition, however, the
result of `fib` must be less than 10,000, so do not execute if z < 10000 is
false.

==== _Object Space Definition_ ====
The `space` key in the hash-table allows the programmer to define a number of
objects that will be available to the supervisor via `$.space` throughout the
duration of the execution of the program. The use of this in the above example
is straightforward. The programmer wants to maintain a list of all prime 
numbers that have been discovered, so he maintains a prime_list that is 
persistent until the program execution stops. This is opposed to a local
variable instance, such as `var n = 100;` in `supervisor()`, that is not saved
between each invocation of `supervisor()`. This design decision was made for
illustration of this concept--in practice, `n` would probably be stored in 
`$.space` as well.

=== `supervisor()` function ===
The supervisor handles all logic pertaining to beginning, ending, and/or
looping the program. The supervisor is the first and last function to be 
invoked in any tnic program. In addition, it is called once all modules are
finished executing; if it returns true, the program will begin executing again,
following the flow defined in `init()`. If it returns false, the program will
stop. We'll similarly illustrate how the supervisor function works by utilizing
the example from above, which is copied here:
{{{
function supervisor ($) {
    var n = 100;
    if ($.space.counter >= n) {
        return false;
    }
    else {
        if (true === $.prime.result) {
            $.space.prime_list.add(space.fib.result);
        }
        $.space.counter++;
        return true;
    }
}
}}}

==== _The `$` Variable_ ====
The special variable, which we call `$`, is passed into the supervisor function
on its initial invocation, and on each subsequent call if applicable. It acts
as a state object for the supervisor. `$` will always contain the following
properties:
    * space
        * a shared object-space that is persisted between module invocations
    * ns
        * the namespace that the supervisor belongs to
    * (module name).result
        * in the example above, we check the $.fib.result object. This stores the value that `fib` returned during it's last invocation. All modules in the supervisor's namespace will be accessible in this way. Modules in other namespaces are accessible by using the full namespace as the key, e.g.  $['com.tnic.packageA.moduleA'].result.  

==== _The Return Value_ ====
If `supervisor` returns true, the the program will execute following the flow
defined in `init` via guard templates. If `supervisor` returns false, the
program will terminate and the results in `$.space` will be saved.

=== `join()` function ===
`join` is invoked once the supervisor returns `false`. The name `join` was given 
because it has a similar role as the POSIX `pthread_join` function. In tnic,
however, there is no waiting on other threads to be done, so there is no actual
barrier synchronization. The tnic `join` function is simple invoked once the 
supervisor returns `false` because at this point all other modules have
necessarily completed execution and have exited.

== How to Write a Module ==



= Limitations =
In this section, we'll describe certain things that you cannot do with TNIC,
or things that TNIC is not optimized for.

== Sustained, single-threaded execution ==
TNIC is not designed for extended periods of single-threaded execution; TNIC is
designed for distributed computation, and therefore your program modules
should be as small as possible while retaining distinction and description.
It is for this reason that TNIC will kill a module if it executes for more than
30 seconds. To be clear, a program comprised of many modules can run for as long
as necessary, but the time-limit for an individual module is 30 seconds.

== Shared Data Structure ==
As discussed earlier in this article, TNIC supervisors are in charge of
maintaining program space. In the quick-start example, the supervisor receives
a `space` variable as a function argument. The `space` variable structure has
already been defined; its purpose is to place the responsibility of managing
shared storage upon the supervisor. The modules should not attempt to create
any global, shared data structures. All information passed between and shared
among modules should be done in the function's return spacement. Since all
returned results are inserted into the `space` variable and passed onto the
supervisor, the supervisor should therefore properly maintain any data
structures that must transcend the execution of a single 
supervisor-->module-->supervisor cycle. *Note:* no matter what, the modules
will simply not have access to any global variables you attempt to share.

== Tail Recursion ==
Tail recursion is possible in TNIC programs, but must be implemented carefully.
The trivial tail-recursion example in the above example is acceptable for small
numbers. For the example above, however, we stop at n = 100. For tail-recursive
functions, there are two main issues to consider:

1. Direct function calls to other functions are not distributed; that is, they
are run in the same thread and therefore do not take advantage of scaling.

2. All threads are subject to the 30 second timeout, so it is important not to
be under the illusion that you are not subject to the timeout just because
you are calling another function. Since direct tail-recursion is
single-threaded, tail-recursion *is* subject to a 30-second timeout. In addition,
you will not realize the benefit of paralleism because you'll only be utilizing
a single thread.
